---
name: py2to3-bytes-string-fixer
description: |
  Highest-risk semantic skill for Python 2→3 bytes/str boundary fixing.
  Handles I/O boundaries, binary protocols (Modbus, SCADA), EBCDIC mainframe data,
  serial communications, CNC machine text, and mixed-encoding legacy systems.
  Detects and fixes bytes/str mismatches at socket recv/send, file I/O with
  binary vs. text modes, struct.pack/unpack flows, and legacy protocol handlers.
---

# Skill 3.1: Bytes/String Boundary Fixer

## Why This Is the Highest-Risk Semantic Skill

Python 2 conflates bytes and str: a byte string `b'abc'` and a unicode string `u'abc'`
were subtly different, but plain `'abc'` was bytes under Python 2 yet str under Python 3.
This ambiguity **lives at every I/O boundary**:

- **SCADA/Modbus protocols**: Read binary frames over TCP socket → must stay bytes until
  you parse fields with `struct.unpack()`. If treated as text, byte values are corrupted.
  Endianness matters. CRC calculations break if bytes are decoded prematurely.

- **Mainframe EBCDIC**: Legacy COBOL/RPG systems send EBCDIC-encoded data (e.g., `cp500`
  or `cp1047`). Hardcoded byte comparisons in Python 2 code (e.g., `b == 0xC1` to check
  for 'A' in EBCDIC) silently fail if you mix cp037 vs cp500. ASCII/UTF-8 decode will
  garble the data completely.

- **Serial port reads**: CNC machines, lab instruments, older devices send binary frames
  with packed structs, checksums, and mode bytes. Data must flow as bytes through parsing
  logic; only final display/logging should decode to str.

- **Binary file I/O**: Python 2 `open(f)` reads bytes; Python 3 `open(f)` reads str.
  Blindly changing to `open(f, 'rb')` in some paths but not others causes inconsistency.

- **Mixed encodings in one system**: Legacy data warehouses mix ASCII file exports (UTF-8
  or Latin-1) with binary packed-binary protocol frames, all flowing through one module.
  One function may need bytes, another needs str—the boundary is the critical zone.

**The cost of error**: Wrong boundary classification means:
- Silent data corruption (SCADA controllers receiving garbage commands)
- Protocol parsing failures (CRC mismatches, field offsets wrong)
- Mainframe sync issues (data can't be re-imported or audited)
- Crashes at runtime (TypeError: expected bytes, got str)

This skill **prevents silent data corruption** by classifying every bytes/str boundary,
auto-fixing clear cases, and escalating ambiguous cases to human review with full context.

---

## Inputs

| Input | From | Notes |
|-------|------|-------|
| **codebase_path** | User | Root directory of the Python 2 codebase |
| **conversion_unit_path** | User or from Phase 2 | Specific module or file to process (or entire codebase) |
| **bytes-str-boundaries.json** | Phase 0 Data Format Analyzer (0.2) | Raw bytes/str boundary detections; lists every potential mix point in AST |
| **data-layer-report.json** | Skill 0.2 | Identifies functions as binary-layer, text-layer, or mixed-layer |
| **migration-state.json** | Migration State Tracker | Tracks what's been done; updates with bytes-str decisions |
| **target_version** | User or config | Python 3.x target (e.g., 3.9, 3.11, 3.12) |
| **--state-file** | User | Path to migration-state.json for decision tracking |
| **--dry-run** | User | Show what would change without modifying files |
| **--auto-only** | User | Skip ambiguous cases; only apply high-confidence fixes |

---

## Outputs

| Output | Purpose |
|--------|---------|
| **Modified source files** | Files with fixes applied (unless --dry-run) |
| **bytes-str-fixes.json** | JSON log of every fix: location, boundary type, fix applied, rationale, confidence |
| **decisions-needed.json** | Ambiguous boundaries that need human review: data flow context, options, impact |
| **encoding-annotations.json** | Every .encode()/.decode() call: codec used, whether it's correct, risk level |
| **bytes-str-boundary-report.md** | Markdown summary for human consumption (generated by generate_boundary_report.py) |

---

## Scope and Chunking

This is the highest-context-cost skill in the suite. Bytes/string boundary analysis requires the agent to reason about data flow across function boundaries, which means it needs to hold more context per file than any other skill. Budget accordingly.

**Mandatory scoping**: Always scope to a single conversion unit. Never run this skill against the entire codebase at once.

**Within a conversion unit**:
- Process 5–10 files per invocation for modules with heavy binary I/O (protocols, serialization, encoding)
- Process 10–20 files per invocation for modules with primarily text-mode operations
- After each batch, save the `bytes-str-fixes.json` and `decisions-needed.json` outputs and update the migration state

**Prioritization within a unit**: Process files in this order:
1. I/O boundary modules (network, file, database) — these define the bytes/str contract
2. Serialization modules — these must agree with the I/O boundary decisions
3. Data processing modules — these consume the contracts established above
4. Everything else

**Human review checkpoints**: After processing the I/O boundary modules, pause and present the `decisions-needed.json` to the user. These decisions propagate to all downstream files — getting them wrong means redoing the entire unit.

**Key principle**: Quality over speed. This skill's output correctness determines whether Phase 3 succeeds or fails. Take small bites and verify as you go.

---

## Workflow

### 1. Load Phase 0 Boundary Map

The Phase 0 Data Format Analyzer produces a `bytes-str-boundaries.json` listing every AST node
where bytes and str interact, including file, line, boundary type, source variable, destination usage, context, and confidence scores.

See `references/EXAMPLES.md` for sample boundary map structure.

Load this JSON as the **starting point** for all downstream analysis.

### 2. Classify Each Boundary

For every boundary in the map, determine its classification:

#### **BYTES-NATIVE** (keep as bytes)

High confidence that data should remain bytes throughout: struct.pack/unpack, socket.recv/send, os.read, file I/O in 'rb' mode, serial port reads, CRC/checksum calculations.

Key principle: Data flows as bytes through parsing logic; only final display/logging should decode to str.

#### **TEXT-NATIVE** (decode to str)

High confidence that data is intended as text: str.format/%, print()/logging, UI display, configuration files, JSON serialization, database string columns.

Key principle: Display layer always uses str.

#### **MIXED/AMBIGUOUS** (needs human decision)

Boundary is unclear or crosses layer boundaries in ways that need human judgment: data flows from binary source to string operation without explicit conversion, legacy code with implicit type mixing, encoding not specified (especially EBCDIC or non-UTF-8).

See `references/EXAMPLES.md` for detailed classification examples and ambiguous case patterns.

---

### 3. Apply Automatic Fixes (High Confidence)

For boundaries classified as BYTES-NATIVE or TEXT-NATIVE with confidence ≥ 0.85, apply automatic fixes:

**BYTES-NATIVE fixes:**
- Struct unpack results: Keep bytes, unpack to ints
- File binary mode: Ensure 'rb' mode specified
- Socket recv: Keep as bytes, assert clarity

**TEXT-NATIVE fixes:**
- Decode for display: Explicit codec on .decode()
- File text mode: encoding='utf-8' specified
- String formatting: Type-aware checks before concatenation

See `references/EXAMPLES.md` for detailed before/after transformation examples for all fix patterns.

---

### 4. Generate decisions-needed.json for Ambiguous Cases

For boundaries with confidence between 0.5–0.85 or missing context, record:
- File, line, boundary type, source code
- Data flow context (source, current operation, next use)
- Confidence scores (bytes vs text)
- Decision options (with description and rationale)
- Impact assessment (what goes wrong if we choose incorrectly)
- Next step (who should review and what they should verify)

See `references/EXAMPLES.md` for complete decisions-needed.json structure with EBCDIC comparison example.

---

### 5. Record Encoding Annotations

For every `.encode()` and `.decode()` call in the codebase, record:
- File, line, operation type (encode/decode)
- Codec used (or "None (implicit UTF-8)" if missing)
- Context (what is being encoded/decoded)
- Confidence score (how certain we are about this codec)
- Risk level (low/medium/high)
- Note (why this codec is correct or a concern)

See `references/EXAMPLES.md` for complete encoding-annotations.json structure with examples across Modbus, EBCDIC, and legacy systems.

---

## SCADA/Modbus Protocol Handling

Modbus and similar binary protocols require **strict bytes discipline**:

1. Read frames as bytes from socket/serial
2. Parse with struct.unpack on bytes
3. Validate CRC on bytes
4. Build response frames in bytes
5. Only decode for logging/display

Key principle: Data flows as bytes through the entire parsing and construction pipeline. Only the logging/display layer decodes to str.

See `references/EXAMPLES.md` for complete flow example with all five steps.

---

## EBCDIC Handling

Mainframe systems using EBCDIC require explicit codec specification at data ingestion:

1. **Identify EBCDIC data sources** from data-layer-report.json: files marked as EBCDIC, functions documented as "mainframe data handler", byte comparisons with EBCDIC-range values (0xC1–0xE9)

2. **Add explicit decode at ingestion point**: Read file as bytes, then decode with explicit codec at clear boundary

3. **Verify codec variant**: cp500 (international), cp037 (US/Canada), cp1047 (Latin-1), cp273 (German). Document which variant is used in function docstring.

4. **Handle mixed records**: Some fields EBCDIC (decode), some binary (struct.unpack), all at same ingestion point

See `references/EXAMPLES.md` for EBCDIC identifier detection, explicit decode example, codec variants, and mixed-record patterns.

---

## File I/O Handling

### Binary Files
- Python 2: `open(file)` implicitly reads bytes
- Python 3: Must explicitly specify `'rb'` mode for bytes

### Text Files
- Python 2: `open(file)` reads bytes, treats as str implicitly
- Python 3: Must explicitly specify `encoding='utf-8'` for str

### Legacy Non-UTF-8 Codecs
- Latin-1 files: `encoding='latin-1'`
- EBCDIC files: Read as bytes ('rb'), then decode with specific codec (cp500, cp037, etc.)

See `references/EXAMPLES.md` for file I/O handling examples: binary files, text files with encoding, and legacy non-UTF-8 codecs.

---

## Integration with Migration State Tracker

Record every bytes/str decision in migration-state.json including:
- Module name, phase, bytes_str_status
- Count of decisions made and pending
- Overall risk level for the module
- Notes on key decisions and pending items

See `references/EXAMPLES.md` for migration state tracking example.

---

## Model Tier

**Sonnet** (with Haiku pre-processing). The core task — deciding whether a variable holds bytes or text and choosing the correct fix — requires semantic understanding of data flow. Haiku cannot reliably make these decisions.

Decomposition: Haiku identifies all byte/str boundary locations (calls to encode/decode, socket.recv, file I/O without encoding, struct.pack). Sonnet receives only these locations with surrounding context and decides the fix strategy. This reduces Sonnet's token consumption by ~70% compared to feeding it entire files.

## References

- **encoding-patterns.md**: EBCDIC codecs, mixed encoding detection
- **bytes-str-patterns.md**: Common bytes/str anti-patterns and fixes
- **scada-protocol-patterns.md**: Modbus, CANbus, serial protocol specifics
- **serialization-migration.md**: struct.pack/unpack, pickle, protobuf in Py3

---
- `references/SUB-AGENT-GUIDE.md` — How to delegate work to sub-agents: prompt injection, context budgeting, parallel execution

## Success Criteria

- [ ] All socket recv/send operations stay as bytes
- [ ] All struct.pack/unpack operations work on bytes, results are ints/tuples
- [ ] All file I/O has explicit mode ('rb'/'r') or encoding parameter
- [ ] All .decode() calls have explicit codec (not implicit UTF-8 for EBCDIC data)
- [ ] All EBCDIC data ingestion points have cp500/cp037/cp1047 decode
- [ ] No implicit str←→bytes operations (e.g., comparing bytes to str literal)
- [ ] bytes-str-fixes.json has 100% coverage of detected boundaries
- [ ] decisions-needed.json has clear options and impact analysis for ambiguous cases
- [ ] encoding-annotations.json documents every codec used and its correctness
